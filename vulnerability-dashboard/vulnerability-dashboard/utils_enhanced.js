// Enhanced utils.js for web environment (no Node.js dependencies)

/**
 * Function that fetches the data from the gitlab api and returns the json of said objects
 * @param {String} endPoint the gitlab api endpoint
 * @param {String} privateToken the access token of the project 
 * @returns a JSON of the requested object 
 */
export async function getData(endPoint, privateToken) {
    if((typeof endPoint != "string") || (typeof privateToken != "string"))
        throw new TypeError("[Error processing endpoint and/or token]: They must be Strings");

    const mHeaders = new Headers();
    mHeaders.append("PRIVATE-TOKEN", privateToken);

    const requestOpt = {
        method: "GET",
        headers: mHeaders,
    }

    const response = await fetch(endPoint, requestOpt);
    
    if(!response.ok)
        throw new Error("[Error retrieving data from server]: " + response.status + " - "+ response.statusText);

    const jsonResponse = await response.json();
    return jsonResponse;
}

/**
 * Function that reads the data from the given path and returns a json object of it
 * @param {String} filePath the path where the file reside
 * @returns returns the content in form of an json object
 */
export async function readFile_JSON(filePath) {
    if((typeof filePath != "string"))
        throw new TypeError("[Error processing path]: It must be a String");
    
    try {
        const response = await fetch(filePath);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const obj = await response.json();
        return obj;
    } catch (error) {
        console.error("Error reading JSON file:", error);
        throw error;
    }
}

/**
 * Function that sets the config file in the given path with the given obj
 * Note: In a web environment, this would typically send data to a server
 * @param {String} filePath the path of the config file
 * @param {Object} obj the object that represents the content of the file to set
 */
export function writeFile_JSON(filePath, obj) {
    if((typeof filePath != "string") || (typeof obj != "object"))
       throw new TypeError("[Error processing path and/or settings]: Path must be a String, settings must be an object");

    // In a real web application, this would send the data to a server endpoint
    // For demo purposes, we'll just log it and store in localStorage
    console.log("Configuration would be saved:", obj);
    localStorage.setItem('vd_settings', JSON.stringify(obj));
    
    // You could also send to a server like this:
    // fetch('/api/save-config', {
    //     method: 'POST',
    //     headers: { 'Content-Type': 'application/json' },
    //     body: JSON.stringify(obj)
    // });
}

/**
 * Load artifact data from various sources
 * @param {String} project - Project name (juiceshop or todoapp)
 * @param {String} artifactType - Type of artifact (sast, dast, etc.)
 * @returns Promise with artifact data
 */
export async function loadArtifactData(project, artifactType) {
    // In a real implementation, this would:
    // 1. Check if artifacts are available locally
    // 2. Fetch from GitLab API if configured
    // 3. Return mock data as fallback
    
    try {
        // Try to load from local artifacts directory first
        const artifactPath = `./artifacts/${project}_${artifactType}.json`;
        const response = await fetch(artifactPath);
        
        if (response.ok) {
            return await response.json();
        }
    } catch (error) {
        console.log(`No local artifact found for ${project}_${artifactType}, using mock data`);
    }
    
    // Return mock data if no real artifacts are available
    return getMockArtifactData(project, artifactType);
}

/**
 * Get mock artifact data for demonstration
 * @param {String} project - Project name
 * @param {String} artifactType - Artifact type
 * @returns Mock artifact data
 */
function getMockArtifactData(project, artifactType) {
    const mockData = {
        juiceshop: {
            sast: {
                vulnerabilities: [
                    { severity: "HIGH", type: "SQL Injection", file: "app.js", line: 42, description: "Potential SQL injection vulnerability" },
                    { severity: "MEDIUM", type: "XSS", file: "login.html", line: 15, description: "Cross-site scripting vulnerability" },
                    { severity: "LOW", type: "Hardcoded Secret", file: "config.js", line: 8, description: "Hardcoded API key found" }
                ],
                summary: { high: 1, medium: 1, low: 1, total: 3 }
            },
            dast: {
                vulnerabilities: [
                    { severity: "HIGH", type: "Authentication Bypass", url: "/admin", description: "Admin panel accessible without authentication" },
                    { severity: "MEDIUM", type: "Information Disclosure", url: "/api/users", description: "Sensitive user data exposed" }
                ],
                summary: { high: 1, medium: 1, low: 0, total: 2 }
            },
            dependency_scanning: {
                vulnerabilities: [
                    { severity: "HIGH", package: "lodash", version: "4.17.15", cve: "CVE-2020-8203", description: "Prototype pollution vulnerability" },
                    { severity: "MEDIUM", package: "express", version: "4.16.4", cve: "CVE-2019-5413", description: "Open redirect vulnerability" }
                ],
                summary: { high: 1, medium: 1, low: 0, total: 2 }
            },
            container_scanning: {
                vulnerabilities: [
                    { severity: "HIGH", package: "openssl", version: "1.1.1", cve: "CVE-2021-3711", description: "Buffer overflow in SM2 decryption" }
                ],
                summary: { high: 1, medium: 0, low: 0, total: 1 }
            },
            fuzzing: {
                vulnerabilities: [
                    { severity: "MEDIUM", endpoint: "/api/search", description: "Input validation bypass detected" }
                ],
                summary: { high: 0, medium: 1, low: 0, total: 1 }
            }
        },
        todoapp: {
            sast: {
                vulnerabilities: [
                    { severity: "MEDIUM", type: "Path Traversal", file: "fileHandler.js", line: 23, description: "Potential path traversal vulnerability" }
                ],
                summary: { high: 0, medium: 1, low: 0, total: 1 }
            },
            dast: {
                vulnerabilities: [
                    { severity: "LOW", type: "Missing Security Headers", url: "/", description: "Missing X-Frame-Options header" }
                ],
                summary: { high: 0, medium: 0, low: 1, total: 1 }
            },
            dependency_scanning: {
                vulnerabilities: [],
                summary: { high: 0, medium: 0, low: 0, total: 0 }
            },
            container_scanning: {
                vulnerabilities: [],
                summary: { high: 0, medium: 0, low: 0, total: 0 }
            },
            fuzzing: {
                vulnerabilities: [],
                summary: { high: 0, medium: 0, low: 0, total: 0 }
            }
        }
    };
    
    return mockData[project]?.[artifactType] || { vulnerabilities: [], summary: { high: 0, medium: 0, low: 0, total: 0 } };
}

